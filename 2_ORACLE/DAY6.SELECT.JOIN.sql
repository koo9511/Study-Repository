-- DAY 6 : JOIN, SET(집합) 연산자

-- 부서코드와 직급코드를 함께 그룹을 묶고, 급여의 합계를 구함
-- ROLLUP 함수 적용

SELECT DEPT_ID, JOB_ID, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL
AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID, JOB_ID);

SELECT DEPT_ID, JOB_ID, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL
AND JOB_ID IS NOT NULL
GROUP BY CUBE(DEPT_ID, JOB_ID);

-- GROUPING *********************************************
-- SELECT 절과 GROUP BY 절에서만 사용함
-- 컬럼을 그룹별로 묶을 때 사용함
-- 분석을 위한 함수임.
-- 그룹 묶인 값(0)이닞, 집계값(1)인지 구분하기 위해 사용함

SELECT DEPT_ID, JOB_ID, SUM(SALARY) ,
        GROUPING(DEPT_ID) "그룹 묶인 상태"
FROM EMPLOYEE;
WHERE DEPT_ID IS NOT NULL
AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID,JOB_ID);

-- GRUOP SETS
-- 그룹별로 묶어서 처리한 여러 개의 SELECT 문을 하나로 합린 결과

-- UNION ALL 집합연산자 사용한 경우
SELECT DEPT_ID, JOB_ID, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID, JOB_ID, MGR_ID
UNION ALL
SELECT DEPT_ID, NULL, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID, MGR_ID
UNION ALL
SELECT NULL, JOB_ID, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY JOB_ID, MGR_ID;

-- 위의 처리결과를 GROUP SETS 으로 바꾸었을 때
SELECT DEPT_ID, JOB_ID, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY GROUPING SETS((DEPT_ID, JOB_ID, MGR_ID),(DEPT_ID,MGR_ID),(JOB_ID, MGR_ID));

-- 분석함수
-- RANK() 함수 : 순위(등수) 매기는 함수

-- 지정하는 값의 순위를 알고자 할 때
-- RANK(지정값) WITHIN GROUP ( ORDER BY 컬럼명 정렬 방식)

-- 예 : 급여 230만원이 전체 급여 중 몇 등인지
SELECT RANK(2300000) WITHIN GROUP (ORDER BY SALARY DESC) 순위
FROM EMPLOYEE
ORDER BY 순위;

-- 급여 전체 값에 순위를 매기고자 할 때
-- RANK() OVER(ORDER BY 컬럼명 정렬방식)
SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) 순위
FROM EMPLOYEE
ORDER BY 순위;

-- JOIN(조인)
-- 여러 개의 테이블을 하나로 합칠 때 사용함
SELECT EMP_NAME, DEPT_ID
FROM EMPLOYEE;

SELECT DEPT_ID, DEPT_NAME
FROM DEPARTMENT;

-- 오라클 전용구문
-- EMPLOYEE 테이블과 DEPARTMENT 테이블을 하나로 합침
SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID;

-- 오라클 전용구문에서는 테이블에 대한 별칭 사용할 수 있음
SELECT EMP_NAME, E.DEPT_ID, DEPT_NAME   
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID;

-- ANSI 표준구문 사용
SELECT *
FROM EMPLOYEE
JOIN DEPARTMENT USING (DEPT_ID);

SELECT EMP_NAME, DEPT_ID, DEPT_NAME
FROM EMPLOYEE
-- INNER JOIN DEPARTMENT USING (DEPT_ID);
JOIN DEPARTMENT USING (DEPT_ID); -- INNER 생랼할 수 있음

-- DEPARTMENT 와 LACATION 합침
-- 부서명, 지역코드, 지역명, 국가코드 조회
    
-- 오차클 전용구문
SELECT *
FROM DEPARTMENT, LOCATION
WHERE LOC_ID = LOCATION_ID;

-- ANSI 표준구문
SELECT *
FROM DEPARTMENT
JOIN LOCATION ON (LOC_ID = LOCATION_ID);

SELECT DEPT_NAME, LOC_ID, LOC_DESCRIBE, COUNTRY_ID
FROM DEPARTMENT
JOIN LOCATION ON (LOC_ID = LOCATION_ID);

-- 직원 테이블과 직급(JOB) 테이블 합쳐서
-- 사번, 이름, 직급명 조회

SELECT *
FROM EMPLOYEE E, JOB J
WHERE E.JOB_ID = J.JOB_ID;

-- ANSI
SELECT *
FROM EMPLOYEE
JOIN JOB USING (JOB_ID);

SELECT EMP_ID,EMP_NAME,JOB_TITLE
FROM EMPLOYEE
JOIN JOB uSINg (JOB_ID);

-- ANSI 표준구문의 USING 사용자
-- 여러 개의 컬럼을 기술할 ㅅ ㅜ있음

SELECT *
FROM EMPLOYEE2
JOIN DEPARTMENT USING (DEPT_ID, LOC_ID);
-- '10A1' - '10A1' : 조인에 포함

-- N개의 테이블 조인시 조인의 순서가 중요함
-- 직원의 사버나, 이름, 직급명, 부서명, 근무지역명, 근무국가명 조회

-- 오라클 전용구문
SELECT *
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L, COUNTRY C
WHERE E.JOB_ID = J.JOB_ID
AND E.DEPT_ID = D.DEPT_ID
AND D.LOC_ID = L.LOCATION_ID
AND L.COUNTRY_ID = C.COUNTRY_ID;

SELECT EMP_ID, EMP_NAME,JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L, COUNTRY C
WHERE E.JOB_ID = J.JOB_ID
AND E.DEPT_ID = D.DEPT_ID
AND D.LOC_ID = L.LOCATION_ID
AND L.COUNTRY_ID = C.COUNTRY_ID;

-- ANSI 표준구문
SELECT *
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
JOIN DEPARTMENT USING (DEPT_ID)
JOIN LOCATION ON (LOC_ID = LOCATION_ID)
JOIN COUNTRY USING (COUNTRY_ID);

-- 조인의 기본은 INNER EQUAL JOIN DLA.
-- 연결된 두 컬럼의 값이 일치하는 행들만 조인에 포함됨
-- 일치하지 않는값에 대한 행은 조인에서 제외됨.

-- 값이 일치하지 않는 행도 조인에 포함시키려면
-- OUTER EQUAL JOIN 을 사용하면 됨.
-- 예를들어, EMPLOYEE의 DEPT_ID 의 NULL 과
-- DEPARTMENT dml DEPT_ID 의 NULL 을 추가해서
-- EQUAL 상태가 되게 만듦( NULL = NULL)
-- EMPLOYEE.DEPT_ID = DEPARTMENT_DEPT_ID(+) 추가

SELECT DISTINCT DEPT_ID
FROM EMPLOYEE;

SELECT EMP_NAME, DEPT_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID(+); -- LEFT OUTER JOIN

-- ANSI 표준구문
SELECT EMP_NAME, DEPT_NAME
from employee

outer join department using (dept_id);

-- ANSI 표준구문 : FULL OUTER JOIN 사용할 수 있음

select *
from location, country;

select *
from location
cross join country;

-- NON EQUAL JOIN 에
-- SAL_GRADE 테이블의 LOWEST ~ HIGHEST 범위의 급여에 대한 조인처리

--ANSI
SELECT *
FROM EMPLOYEE
JOIN SAL_GRADE ON (SALARY BETWEEN LOWEST AND  HIGHEST);

--ORACLE
SELECT EMP_NAME, SALARY, SLEVEL
FROM EMPLOYEE, SAL_GRADE
WHERE SALARY BETWEEN LOWEST AND HIGHEST;

-- SELF JOIN
-- 같은 테이블을 두 번 조인하는 경우
-- 같은 테이블에서 다른 컬럼의 값을 참조하고 있는 경우
-- MGR_ID 이 EMP_ID 사용하고 있음. : FOREIGN KEY

--ansi
select *
from employee e
join employee m on (e.mgr_id = m.emp_id);

-- 직급이 대리이면서, 근무지역이 아시어지역에 근무하는 직원정보 조회
-- 사원명, 소속부서명, 직급명, 근무지역명, 국가명, 급여, 급여등급 조회
SELECT EMP_NAME 사원명, DEPT_NAME 부서명, JOB_TITLE 직급명, LOC_DESCRIBE 근무지역명, COUNTRY_NAME 국가명, SALARY 급여, SLEVEL 급여등급
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
JOIN DEPARTMENT USING (DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOC_ID)
JOIN COUNTRY USING (COUNTRY_ID)
JOIN SAL_GRADE ON (SALARY BETWEEN LOWEST AND HIGHEST)
WHERE JOB_TITLE = '대리' AND LOC_DESCRIBE LIKE '아시아%';

