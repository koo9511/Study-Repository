[컬렉션]
자료구조(Data Structure)
  : 자료(Data:값)을 메모리에서 구조적으로 처리하는 방법론
  1. 변수(Variable) 공간을 이용하는 방법
	=> 값을 기록하기 위한 공간에 해당 자료형 값 1개를 기록하는 방법
  2. 배열(Array) 공간을 이용하는 방법
	=> 같은 종류(자료형)의 값 여러 개를 메모리에 기록하는 방법
  3. 선형리스트를 이용하는 방법
	=> 배열과 같은 연속된 공간을 나열해서 사용하는 방법
  	=> 연결리스트(Linked List) 를 사용하는 방법
  4. 스택(Stack) 방식을 이용하는 방법
  5. 큐(Queue) 방식으로 이용하는 방법
  6. 트리(tree) 방식
  7. 그래프(Graph) 방식

 - 자료를 추가, 삭제, 수정, 검색, 정렬 등과 같은 알고리즘을 자료구조를 사용해서
   기록된 데이터에 적용함
 - 자바에서는 컬렉션 프레임워크(Collection Framework) 라는 것으로 
	자료구조용 클래스를 미리 만들어서 제공함
//-----------------------------------------------------------------------------------
 
 - 장점 : 배열 단점을 보완하였음.
	=> 배열의 단점
	  1. 한번 크기를 지정하면, 변경할 수 없다.
		필요에 따라 늘리거나 줄일 수 없음.
		>> 공간의 크기가 부족하면 에러가 발생하므로,
		   넉넉한 크기로 할당하게 됨.
		>> 메모리를 낭비하는 결과를 초래함.
	  2. 배열에 기록된 데이터에 대한 중간위치의 추가, 삭제가 불편함
		>> 맨 앞이나 중간 위치에 추가할 경우, 
		   그 위치의 데이터부터 마지막에 기록된 데이터까지를
		   하나씩 뒤로 밀어내고, 추가해야 함
		>> 삭제의 경우도 마찬가지임.
		>> 배열의 추가, 삭제에 대한 알고리즘이 복잡하다.
	  3. 한 타입의 데이터만 저장한다.

 - 컬렉션은 저장하는 크기의 제약이 없다.
   자료를 구조적으로 처리하는 자료구조가 내장이 되어 제공이 됨
	>> 추가, 삭제, 정렬 등의 기능처리가 간단하게 해결됨.
	>> 자료구조적인 알고리즘 구현이 필요없다.
   여러 타입을 저장할 수 있다.
 - 객체만 저장함 : 필요할 경우 데이터의 저장을 위해 Wrapper 클래스를 사용함

 - 컬렉션은 두 부류로 나눠짐
	Collection 인터페이스의 후손들
		>> List 인터페이스 계열
		>> Set 인터페이스 계열
	Map 인터페이스의 후손들

 - 특징
	* Set : 저장되는 순서가 유지되지 않음.
		중복값 허용 안 함.
	* List : 저장되는 순서가 유지됨. (배열처럼 이용할 수 있음)
		=> 순번(index) 사용할 수 있음
		중복값 허용함.
	* Map : 저장시 키(key)와 객체(value) 두 개를 쌍으로 저장함
		키는 Set 방식으로 처리되고, 값 객체는 List 방식으로 처리

 - 상속에 대한 계층구조
	- Collection - Set - AbstractSet - HashSet - LinkedHashSet
					       저장되는 순서유지
				    - TreeSet
					자동 오름차순정렬됨

	- Collection - List - AbstractList - ArrayList
		   배열처럼 사용		(Thread Safe 기능없음)
				     - LinkedList
					(Thread Safe 기능없음)
				     - Vector
					(Thread Safe 기능포함)
	- Map - AbstractMap - HashMap
				(Thread Safe 기능없음)
			   - HashTable
				(Thread Safe 기능포함)


//-----------------------------------------------------------------------------
 * 제네릭(Generic) 기능
	: 일반적으로 컬렉션 프레임워크에서 주로 사용됨
	=> 한가지 종류의 클래스 사용으로 제한을 거는 기능
	=> 컬렉션들은 여러 종류의 클래스 객체들을 저장할 수 있음
		>> 하나씩 꺼내서 사용할 경우, 클래스 타입을 확인해서
		   사용해야 함.
	=> 제네릭을 사용할 수 있는 클래스만 이용할 수 있음.
		>> 사용 가능 확인 :
		class 클래스명<문자>
		** <문자> => 제네릭

	=> 사용방법
	   클래스명<사용할 클래스명> 레퍼런스변수 = new 
			생성자<사용할 클래스명>();

	   >> 제네릭이 설정된 레퍼런스를 메소드로 전달할 경우,
		받아주는 메소드의 매개변수도 같이 제네릭 설정해야 함
		예>
		List<String> list = new ArrayList<String>();

		레퍼런스.메소드(list);

		---> 접근제어자 반환자료형 메소드명(List<String> alist)
		    { .... }

	    >> 제네릭이 설정된 레퍼런스를 리턴하는 경우에도,
		메소드 해드의 반환자료형에도 반드시 같은 제네릭 설정
		해 주어야 함

		예>
		접근제어자 List<String> 메소드명(.......)
		{			
         	  List<String> list = new ArrayList<String>():
		  처리내용
		
		  return list;
		}


	   >> 제네릭이 적용된 반환값을 받아주는 변수도 반드시
		같은 타입의 제네릭 선언을 해 주어야 함.

		예>

		List<String> list = 레퍼런스.메소드명(.....);

 ** 제네릭 클래스 만들기 **
	class 클래스명<클래스타입을 대신한 영문자>{ }










