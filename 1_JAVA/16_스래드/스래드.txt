<스래드(thread)>

 * 프로세스 : 현재 시스템에 실행중인 프로그램
 * 스래드 : cpu가 실행하는 실행의 최소 단위
 * cpu 는 한번에 한개의 스래드를 실행함 : 싱글 스래드 프로그램임.
 * 멀티 스래드 프로그램 : 여러 개의 프로세스를 실행함.
	=> 기본적으로 cpu는 실행 요청 순서에 따라 프로세스의 실행순서를
	   결정함 : 작업 스케쥴링이라고 함.(직렬처리임)
	=> 실행 요청된 프로세스들을 병렬처리함.
	=> 각 프로세스들의 실행내용을 쪼갬
		>> 쪼갠 한 조각 == 스래드라고 함.
		>> 요청 순서에 상관없이(cpu가 임의로 정함) 
		   각 프로세스의 스래드를 하나씩 실행함.
		>> 전체 실행에 걸리는 시간은 동일함.
	=> 여러 프로세스가 동시에 실행되는 것처럼 보이게 만드는 기술

 - 자바에서의 멀티스래딩 프로그램을 작성하려면
	1. 해당 클래스는 반드시 java.lang.Thread 클래스를 상속받아야 함

		class 클래스명 extends Thread {}

	  => 만약, 다른 클래스를 상속받은 경우라면, 
		Runnable 인터페이스를 상속받으면 됨

		class 클래스명 implements Runnable {}

	2. 상속 처리 후, run() 메소드 오버라이딩함.

		@Override
		public void run()
		{

		}


	3. run() 메소드 {} 안에 실행에 필요한 소스 작성함.

	ex>
	public class A extends Thread
	{
		@Override
		public void run()
		{
			비행기가 왼쪽에서 오른쪽으로 지나가는 내용
		}
	}

	public class B extends Thread
	{
		@Override
		public void run()
		{
			총을 밑에서 위로 쏘는 내용
		}
	}
	

 [멀티 스래딩 프로그램 실행 방법]
	1. Thread or Runnable 을 상속받아 만들어진 클래스들에 대한
		객체 생성함
		=> 동시 실행을 원하는 클래스 모두 객체 생성함

		ex>
		A a = new A();
		B b = new B();

	2. Thread 를 상속받은 클래스일 때는,
		Thread 클래스에 대한 객체 생성함

		ex>
		Thread t1 = a;
		Thread t2 = b;

	  만약, Runnable 인터페이스를 상속받은 클래스 일 때는
		Thread t1 = new Thread(a);
		Thread t2 = new Thread(b);


	3. 생성된 스래드 객체를 실행시킴
		=> start() 메소드 사용함
		ex>
		t1.start();
		t2.start();

		*** start() 메소드가 run()을 작동시킴 ***

 ** 스래드 스케쥴링 **
	: 여러 개의 스래드가 동시에 실행을 요청할 때, cpu가 실행의
	순서를 정함
	=> 스래드 실행에 대한 우선순위를 정할 수 있음
		스래드레퍼런스.setPriority(우선순위값);
	=> 우선순위값 : Thread.MAX_PRIORITY		//10
		     Thread.NORM_PRIORITY	//5 (기본값)
		     Thread.MIN_PRIORITY		//1
	=> 우선순위 확인 : 
		int 변수 = 스래드레퍼런스.getPriority();
		ex>
		Thread t = new 스래드상속클래스생성자();
		t.setPriority(7);	//1~10 사이의 정수 사용 가능함



 ** 스래드 컨트롤 **
 - 스래드 구동시, 필요할 경우 해당 스래드의 작동을 잠깐 멈추게 할 수도 있음
	=> sleep(밀리초) : static 메소드임
	Thread.sleep(3000);	//1000 이 1초임.

 - 스래드레퍼런스.interrupt();
	//스래드를 강제로 중지시킴

 - 스래드레퍼런스.join();	//스래드가 중지될 때까지 기다림
 - 스래드레퍼런스.join(밀리초);	//지정된 시간동안만 기다림



 ** 동기화(synchronization) **
	: 여러 스래드가 하나의 데이터를 공유하게 될 경우
	 (공유영역 : critical section)
	 스래드 간섭(interference)과 
	 메모리 일관성 오류(consistency error)가 발생함
	=> 스래드 간섭 : 하나의 스래드가 값을 변경하려할 때 
		다른 스래드가 끼어들 경우
	=> 메모리 일관성(일치) 오류 : 공유된 데이터 값이 일치하지 않을 때
	=> 해결방법 : 동기화 처리
		>> 스래드들이 공유하는 데이터를 한 스래드가 사용하는
		   동안 다른 스래드는 접근 못 하게 블로킹 처리하는
		   방법임.
	   	>> 공유 데이터를 사용하는 메소드의 해드
		   반환자료형 앞에 synchronized 키워드 추가함
		   또는 소스 상의 공유영역을 
		       synchronized(공유데이터필드){} 으로 묶음

		접근제어자 synchronized 반환자료형 메소드명([....])
		{
			공유데이터 사용구문
		}

		>> synchronized 블럭을 사용할 수도 있음
	
		접근제어자 반환자료형 메소드명([......])
		{
		     synchronized(공유객체) {
			스래드들이 공유하는 데이터 사용구문
		     }
		}


 ** 스래드 조정 **
	: 두 개의 스래드를 작동하는 에플리케이션의 경우
	하나의 스래드는 공유 데이터에 값을 넣는 일을 하고(생산자),
	두번째 스래드는  그 값을 읽어가는 일을 할 경우(소비자)
	스래드 실행순서에 대해 모르기 때문에 생산자가 값을 넣기 전에
	소비자가 값을 꺼내가는 문제가 생길 수 있음.
	=> 이 문제를 해결하기 위해
	   생산자가 값을 넣기 전에는 소비자는 기다리게 하고

	  public synchronized 반환자료형 값꺼내는메소드()
	  {
		............................

	     if(값이 없으면)	
		wait();
		...........................
	  }

	   생산자가 값을 넣고 나면 기다리는 소비자 스래드를 다시 
	   작동되게 처리함

	  public synchronized void 값넣는메소드(자료형 매개변수)
	  {
		............................

		값을 넣음
		notifyAll();
		...........................
	  }


**장단점**
- 자원을 보다 효율적으로 사용할 수 있다.
- 사용자에 대한 응답성(responseness)이 향상된다. - 작업이 분리되어 코드가 간결해 진다.
- 작업이 분리되어 코드가 간결해 진다.

- 동기화(synchronization)에 주의해야 한다.
- 교착상태(dead-lock)가 발생하지 않도록 주의해야 한다. - 각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야 한다.
- 각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야 한다.






























